<!DOCTYPE HTML>
<html>
<head>
<style>
</style>
</head>
<body>
<table>
<tr><td>
<div style="position:relative">
   <canvas id="grid" width="500px" height="1000px" style="border:1px solid black; position: absolute; left: 0; top: 0; z-index: 0;"></canvas>
   <canvas id="vehicleCanvas" width="500px" height="1000px" style="position: absolute; left: 0; top: 0; z-index: 1;"></canvas>
</div>
</td><td>
<div STYLE="position:absolute; left:550px;" >
   <h3>Control The Vehicle</h3>
   Direction: <input type="text" name="direction" id="direction"><br>
   Speed: <input type="text" name="speed" id="speed"><br>
   Rate of Rotation: <input type="text" name="rotation" id="rotation"><br>
   <button onclick="goPressed(document.getElementById('direction').value, document.getElementById('speed').value, document.getElementById('rotation').value)">Go</button>
   <button onclick="reset()">Reset</button>
</div>
</td></tr>
</table>
<script>
/****************************
 *
 * Global Variables
 *
 ****************************/
var WIDTH_PX = 500;
var HEIGHT_PX = 1000;
var WIDTH_FT = 10;
var HEIGHT_FT = 20;
var FT_2_CELL = 2; //foot
var NUM_VERT_GRIDS = WIDTH_FT * FT_2_CELL;
var NUM_HORIZ_GRIDS = HEIGHT_FT * FT_2_CELL;
var VEHICLE_WIDTH =  2*FT_2_CELL*(WIDTH_PX/NUM_VERT_GRIDS);
var VEHICLE_HEIGHT =  4*FT_2_CELL*(WIDTH_PX/NUM_VERT_GRIDS);

var SECOND_MS = 1000;

//screen bounds including 3 ft buffer
var BUFFER = 3; //feet
var BOUNDS_LEFT = 0 ;
var BOUNDS_RIGHT = WIDTH_PX;
var BOUNDS_TOP = 0;
var BOUNDS_BOTTOM = HEIGHT_PX;

var canvas_grid = document.getElementById('grid');
var context_grid = canvas_grid.getContext('2d');

var canvas = document.getElementById('vehicleCanvas');
var context = canvas.getContext('2d');
var prevTime = 0;
var animating = false;

var global_rotation = 0;

var vehicle = 
{
  x: WIDTH_PX /2 - VEHICLE_WIDTH/2,
  y: HEIGHT_PX/2 - VEHICLE_HEIGHT/2,
  width: VEHICLE_WIDTH,
  height: VEHICLE_HEIGHT,
  borderWidth: 1
};

/****************************
 *
 * Functions
 *
 ****************************/
window.requestAnimFrame = (function(callback) {
  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
  function(callback) {
    window.setTimeout(callback, SECOND_MS / 60);
  };
})();

function drawRectangle(rotation) 
{
   context.beginPath();
   rotate(rotation);
   context.rect(vehicle.x, vehicle.y, vehicle.width, vehicle.height);
   context.fillStyle = '#8ED6FF';
   context.fill();
   context.lineWidth = vehicle.borderWidth;
   context.strokeStyle = 'black';
   context.stroke();
}

function rotate(rotation)
{
   var cx = vehicle.x + VEHICLE_WIDTH/2;
   var cy = vehicle.y + VEHICLE_HEIGHT/2;
   //translate to center of shape
   context.translate(cx, cy);
   var rate =  (rotation) / SECOND_MS;
   global_rotation += rate;
   context.rotate(rate);
   //translate center back to 0,0
   context.translate(-cx, -cy);
}

function deltaTime()
{
   var time = (new Date()).getTime();
   var delta = time - prevTime;
   
   //ignore large values. first call to this function may yield a large value
   if(delta > 50)
   {
      delta = 0;
   }
   
   prevTime = time;
   return delta;
}

function goPressed(direction, speed, rotation)
{
   //adjust angles so that vehicle and global coordinate systems initially line up
   direction -= 90;
   animating = true;
   animate(direction, speed, rotation);
}

function animate(direction, speed, rotation)
{
   
   //determine x component of speed value
   var delta = deltaTime();
   var speedX = feetToPixels(speed) * Math.cos(toRadians(direction));
   var newX = (speedX * delta) / SECOND_MS;
   //determine y component of speed value
   var speedY = feetToPixels(speed) * Math.sin(toRadians(direction));
   var newY = (speedY * delta) / SECOND_MS;

   //move the vehicle
   vehicle.x += newX;
   vehicle.y += newY;

   // clear
   context.clearRect(0, 0, canvas.width, canvas.height);
   drawRectangle(rotation);
   checkRepositionView();
   if(animating)
   {
      // request new frame
      requestAnimFrame(function() {
       animate(direction, speed, rotation);
      });
   }
}

/* @brief Helper function to convert an angel in degrees to radians
 * @param angle The angle to be converted to radians
 * @return The angle in radians
 */
function toRadians (angle) {
  return angle * (Math.PI / 180);
} //end toRadians

/* @brief Helper function to convert feet to pixels
 * @param feet The number of feet
 * @return Number of pixels in feet
 */
function feetToPixels(feet)
{
   return feet * (WIDTH_PX/WIDTH_FT);
} //end feetToPixels


function drawGridlines()
{
   //draw horizontal grid-lines
   for(var i = 0; i < NUM_VERT_GRIDS; i++)
   {
      context_grid.moveTo(i*(WIDTH_PX/NUM_VERT_GRIDS),0);
      context_grid.lineTo(i*(WIDTH_PX/NUM_VERT_GRIDS),HEIGHT_PX);
      context_grid.stroke();
   }

   //draw vertical grid-lines
   for(var i = 0; i < NUM_HORIZ_GRIDS; i++)
   {
      context_grid.moveTo(0,i*(HEIGHT_PX/NUM_HORIZ_GRIDS));
      context_grid.lineTo(WIDTH_PX, i*(HEIGHT_PX/NUM_HORIZ_GRIDS),WIDTH_PX);
      context_grid.stroke();
   } 
}

//reposition viewable area when vehicle reference point travels within 3 feet of screen edge
function checkRepositionView()
{
   var cx = vehicle.x + VEHICLE_WIDTH/2;
   var cy = vehicle.y + VEHICLE_HEIGHT/2;
   //get the vehicle reference point
   var vehRefX = cx * Math.cos(global_rotation) + cy * Math.sin(global_rotation);
   var vehRefY = -cx * Math.sin(global_rotation) + cy * Math.cos(global_rotation);
   context.fillStyle="#FF0000";
   context.fillRect(vehRefX,vehRefY,5,5);
   
   /*
   var brx = vehRefX + feetToPixels(3);
   var bry = vehRefY;
   //get the vehicle reference point
   var brX = brx * Math.cos(rotation) + bry * Math.sin(rotation);
   var brY = -brx * Math.sin(rotation) + bry * Math.cos(rotation);
   console.log(brX + " " + brY);
   context.fillStyle="#FF0000";
   context.fillRect(brX,brY,5,5);
   */
   
   var brx = vehRefX + feetToPixels(BUFFER);
   var bry = vehRefY;
   var blx = vehRefX - feetToPixels(BUFFER);
   var bly = vehRefY;
   var btx = vehRefX;
   var bty = vehRefY - feetToPixels(BUFFER);
   var bbx = vehRefX;
   var bby = vehRefY + feetToPixels(BUFFER);
   
   //console.log(btx + " " + BOUNDS_RIGHT);
   //console.log(vehicle.x + " " + vehicle.y);
   console.log(global_rotation);
   
   var DEBUG = true;
   //draw bounds markers
   if(DEBUG)
   {
      context.fillStyle="#FF0000";
      context.fillRect(brx,bry,5,5);
      context.fillRect(blx,bly,5,5);
      context.fillRect(btx,bty,5,5);
      context.fillRect(bbx,bby,5,5);
   }
   //console.log(blx + " < " + BOUNDS_LEFT + "; " + brx + " > " + BOUNDS_RIGHT + "; " + bby + " > " +  BOUNDS_BOTTOM + "; " + bty  + " < " +  BOUNDS_TOP);
   
   if(blx < BOUNDS_LEFT || brx < BOUNDS_LEFT || btx < BOUNDS_LEFT || bbx < BOUNDS_LEFT ||
      blx > BOUNDS_RIGHT || brx > BOUNDS_RIGHT || btx > BOUNDS_RIGHT || bbx > BOUNDS_RIGHT || 
      bly > BOUNDS_BOTTOM || bry > BOUNDS_BOTTOM || bty > BOUNDS_BOTTOM || bby > BOUNDS_BOTTOM ||
      bly < BOUNDS_TOP || bry < BOUNDS_TOP || bty < BOUNDS_TOP || bby < BOUNDS_TOP)
   {
      console.log("outa");
   }
}

/* @brief Reload the page
 */
function reset()
{
   location.reload();
} //end reset
      
/****************************
 *
 * Main
 *
 ****************************/

drawGridlines();
drawRectangle(0);

console.log(BOUNDS_LEFT);
console.log(BOUNDS_RIGHT);
console.log(BOUNDS_TOP);
console.log(BOUNDS_BOTTOM);

</script>
</body>
</html>